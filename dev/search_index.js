var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = DifferentiableKernelFunctions","category":"page"},{"location":"#DifferentiableKernelFunctions","page":"Home","title":"DifferentiableKernelFunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DifferentiableKernelFunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DifferentiableKernelFunctions]","category":"page"},{"location":"#DifferentiableKernelFunctions._evaluate-Union{Tuple{T}, Tuple{T, Tuple{Any, Partial}, Tuple{Any, Partial}}} where T<:KernelFunctions.Kernel","page":"Home","title":"DifferentiableKernelFunctions._evaluate","text":"_evaluate(k::T, x::DiffPt{Dim}, y::DiffPt{Dim}) where {Dim, T<:Kernel}\n\nimplements (k::T)(x::DiffPt{Dim}, y::DiffPt{Dim}) for all kernel types. But since generics are not allowed in the syntax above by the dispatch system, this redirection over _evaluate is necessary\n\nunboxes the partial instructions from DiffPt and applies them to k, evaluates them at the positions of DiffPt\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableKernelFunctions.lazy_flatten-Tuple","page":"Home","title":"DifferentiableKernelFunctions.lazy_flatten","text":"lazy_flatten(vectors...)\n\nThe output is a lazy form of\n\ncollect(Iterators.flatten(vectors...))\n\ni.e. it is an AbstractArray in contrast to Iterators.flatten(vectors...). So is accessible with getindex and gets default Array implementations for free. In particular it can be passed to Base.PermutedDimsArrayfor lazy permutation andvec()to obtain a lazyBase.ReshapedArray`.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableKernelFunctions.lazy_product-Tuple","page":"Home","title":"DifferentiableKernelFunctions.lazy_product","text":"lazy_product(vectors...)\n\nThe output is a lazy form of\n\ncollect(Iterators.product(vectors...))\n\ni.e. it is an AbstractArray in contrast to Iterators.product(vectors...). So is accessible with getindex and gets default Array implementations for free. In particular it can be passed to Base.PermutedDimsArrayfor lazy permutation andvec()to obtain a lazyBase.ReshapedArray`.\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableKernelFunctions.partial-Union{Tuple{T}, Tuple{Any, Tuple{Vararg{T}}, Tuple{Vararg{T}}}} where T<:Int64","page":"Home","title":"DifferentiableKernelFunctions.partial","text":"Take the partial derivative of a function with two dim-dimensional inputs, i.e. 2*dim dimensional input\n\n\n\n\n\n","category":"method"},{"location":"#DifferentiableKernelFunctions.tangentCurve-Tuple{AbstractArray, Int64}","page":"Home","title":"DifferentiableKernelFunctions.tangentCurve","text":"tangentCurve(x₀, i::IndexType)\n\nreturns the function (t ↦ x₀ + teᵢ) where eᵢ is the unit vector at index i\n\n\n\n\n\n","category":"method"}]
}
